# BitConfig Composer

Интерактивное приложение для разбора и сборки «битовых» конфигураций по JSON-описанию функций (проектов/опций). Позволяет:

- редактировать конфиг как **набор опций**, **битовую строку** или **HEX**;
- видеть, какие **биты** соответствуют каким **функциям** и как они кодируются;
- работать в режимах **дополнения/обрезки** или **«не дополнять/не обрезать»**;
- подсвечивать **MISSING** / **PARTIAL** / **UNKNOWN** и конфликты с **блокировками**.

---

## Демо-сценарий

1. **Загрузите JSON** с описанием функций (кнопка со значком «файл» в блоке «1) Конфигурация»).
2. Нажмите **«Применить»** — из JSON построится раскладка: каждой функции задаются `start` (позиция) и `length` (длина в битах).
3. Перейдите во вкладку **«Опции»**:

   - выберите значения функций из выпадающих списков **или** введите двоичный код длиной `length`.
   - при необходимости заблокируйте поле (иконка «замка»), чтобы защищать от изменений.

4. Во вкладке **«Биты»** или **«HEX»** можно задать конфиг напрямую:

   - в режиме **«не дополнять/не обрезать»** хвост/недостачу сохраняются и подсвечиваются.

5. Внизу блока **«Текущий результат»** доступны поля **BIT/HEX/BigInt** и кнопки **Копировать** (с иконкой и текстом).

---

## JSON-схема

JSON — **массив** функций. Каждая функция задаёт:

- `key` — строковый ключ функции (например `"0"`, `"1"`…),
- `halKey` — технический идентификатор,
- `nameEn` / `nameCn` — названия,
- `introduce` — описание,
- `values` — набор вариантов; у каждого варианта:

  - `value` — **битовый код** (строка из `0/1`),
  - `key`, `nameEn`, `nameCn` — метаданные варианта.

Пример (усечённо):

```json
[
  {
    "key": "0",
    "halKey": "KIND_PROJECT_CODE = 0",
    "nameEn": "PROJECT CODE",
    "values": [
      { "value": "00011011", "key": "AAA21", "nameEn": "ES21 PROJECT" },
      { "value": "00011100", "key": "AAA22", "nameEn": "A01 PROJECT" }
    ]
  },
  {
    "key": "1",
    "halKey": "KIND_AUDIO_VIDEO_SYSTEM = 1",
    "nameEn": "AUDIO+VIDEO SYSTEM",
    "values": [
      { "value": "00000", "key": "VAA00", "nameEn": "BLANK COVER" },
      { "value": "00001", "key": "VAA02", "nameEn": "NON-AUDIO(WITH WIRE)" }
    ]
  }
]
```

**Как вычисляются `start`/`length`:**

- `length` берётся из длины `value` (у всех вариантов одной функции длина должна совпадать).
- `start` — **накапливается** в порядке функций: первая начинается с `0`, следующая — с `start + length` предыдущей и т. д.
  Пример: `PROJECT CODE` (8 бит) → `AUDIO+VIDEO SYSTEM` стартует с позиции `8`, длина 5 бит → следующая начнётся с `13`, и т. п.

> Если в проекте добавлен альтернативный «layout builder» с явной поддержкой `start` в JSON — он будет использован. По умолчанию используется **последовательная** компоновка.

---

## Особенности кодирования/режимы

В панели настроек (над вкладками) доступны два поведения:

- **Дополнение (короче width)**
  `left` — дополнить **слева** нулями;
  `right` — дополнить **справа**;
  `none` — **не дополнять** (короткий вход остаётся таким же, поля вне входа подсвечиваются `MISSING`/`PARTIAL`).

- **Обрезка (длиннее width)**
  `left` — обрезать **слева**;
  `right` — обрезать **справа**;
  `none` — **не обрезать** (лишний хвост сохраняется и показывается отдельным блоком как «неизвестные функции»).

**Важно:**

- В режиме `none`/`none` «Текущий результат» = **исходный вход**. Приложение не подгоняет длину, а только накладывает голову на видимые биты.
- Экспорт **HEX** выравнивается **только до целого байта** (внутренний буфер не меняется).

## Как пользоваться UI

### 1) Конфигурация (верхняя панель)

- **Загрузить JSON** — выбрать файл с конфигурацией; после загрузки — «Файл загружен».
- **Скачать JSON** — выгрузить текущий JSON (состояние редактора).
- **Применить** — применить JSON к раскладке (рассчитать `start/length`), «Конфигурация применена».
- Ниже — **редактор JSON** (можно свернуть в превью) и **таблица раскладки**:

  - свернуть/развернуть (иконки «стрелок»),
  - полная таблица — **виртуализирована** (react-virtuoso).

### 2) Компоновка

- **Опции** — список функций с поиском (не теряет фокус). У каждой:

  - Select с вариантами (ключ, название, битовый код),
  - поле «вручную (N бит)» для ввода бинарного значения,
  - иконка «замок» — заблокировать/разблокировать,
  - индикаторы состояния: `MISSING`, `PARTIAL`, `UNKNOWN`, `LOCKED`.

- **Биты** — введите произвольную битстроку и нажмите **Применить биты**.
- **HEX** — введите HEX и нажмите **Применить HEX**.
- **Режимы нормализации** — в панели над вкладками.
  Для `none`/`none`:

  - при **коротком входе** поля вне покрытия помечаются `MISSING`/`PARTIAL`;
  - при **длинном входе** хвост отображается отдельно (в BITS и HEX).

- **Текущий результат** — BIT / HEX / BigInt + кнопки **Копировать** (иконка+текст, всплывает «Скопировано»).

---

## Подсветка состояний

- **MISSING** — поле **полностью вне** текущей битовой строки (вход короче `start + length`).
- **PARTIAL** — поле **частично покрыто** входом (например, битов не хватает на конец функции).
- **UNKNOWN** — поле целиком покрыто входом, но двоичный код **не совпал** ни с одной опцией.
- **LOCKED** — попытка изменения поля, помеченного как заблокированное (конфликт).

---

## Лицензия

MIT. Используйте свободно, откаты, ишьюсы и предложения приветствуются.
